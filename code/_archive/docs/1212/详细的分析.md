项目现状分析

  当前技术栈:
  - 前端: React + Vite + TypeScript + GSAP + Three.js
  - 运行环境: Electron 桌面应用(触摸屏 Win10 1920x1080)
  - 部署方式: 离线打包可执行文件,运行在图书馆触摸屏上
  - 架构: 纯前端应用,无后端

  关键约束:
  1. 离线运行环境(图书馆触摸屏,可能无网络或内网)
  2. 已经是 Electron 打包的单机应用
  3. 需要接入 DeepSeek AI 解梦功能

  ---
  AI 功能后端架构方案分析

  方案一:轻量 Node 后端(推荐)

  架构设计:
  Electron App (前端 React)
      ↓ HTTP/IPC
  本地 Node 服务 (localhost:3000)
      ↓ HTTPS
  DeepSeek API (云端)

  实现要点:

  1. 后端服务层
    - 技术选型: Express.js (轻量,熟悉度高)
    - 端口: localhost:3000 (仅本地访问)
    - 路由设计:
    POST /api/dream-chat
  Body: { question: string, userId?: string }
  Response: { answer: string }
  2. 核心功能模块:
  backend/
  ├── src/
  │   ├── index.ts           # 服务入口
  │   ├── config.ts          # 配置(API Key等)
  │   ├── services/
  │   │   └── deepseek.ts    # DeepSeek 调用封装
  │   ├── routes/
  │   │   └── chat.ts        # 路由处理
  │   └── prompts/
  │       └── system.ts      # System Prompt 常量
  └── package.json
  3. 与 Electron 集成方式:
    - 方式 A(推荐): Electron 主进程启动 Node 服务
        - 在 electron/main.ts 中 app.on('ready') 时启动后端服务
      - 使用 child_process.spawn 启动
      - 优点: 统一打包,用户无感知
      - 缺点: 需要打包后端代码到 Electron
    - 方式 B: 独立后端服务
        - 用户手动启动后端服务
      - 前端检测服务是否可用
      - 优点: 开发简单
      - 缺点: 用户体验差(需要两步启动)
  4. API Key 管理:
    - 存储位置: backend/.env (不打包进 Electron)
    - 读取方式: 使用 dotenv 包
    - 安全考虑:
        - 环境变量方式传递
      - 或在 Electron 用户数据目录存储配置文件
    // electron/main.ts
  const userDataPath = app.getPath('userData')
  const configPath = join(userDataPath, 'config.json')
  5. 错误处理:
    - API 调用失败: 友好提示 + 重试机制
    - 网络异常: 检测并提示用户
    - 超时控制: 15秒超时

  优点:
  - ✅ 简单直接,符合文档建议的 MVP 方案
  - ✅ 前后端分离,职责清晰
  - ✅ 易于调试和测试
  - ✅ 可以在 Electron 内集成,用户无感

  缺点:
  - ❌ 需要网络连接(图书馆环境需确认)
  - ❌ API Key 需要妥善管理
  - ❌ 增加打包复杂度

  ---
  方案二: Electron IPC + 主进程调用 (备选)

  架构设计:
  React 组件
      ↓ IPC Renderer
  Electron 主进程
      ↓ HTTPS
  DeepSeek API

  实现要点:

  1. 前端调用:
  // src/services/aiService.ts
  const answer = await window.electron.callDeepSeek(question)
  2. Electron Preload:
  // electron/preload.ts
  contextBridge.exposeInMainWorld('electron', {
    callDeepSeek: (question: string) =>
      ipcRenderer.invoke('call-deepseek', question)
  })
  3. 主进程处理:
  // electron/main.ts
  ipcMain.handle('call-deepseek', async (event, question) => {
    // 调用 DeepSeek API
    return answer
  })

  优点:
  - ✅ 无需独立后端服务
  - ✅ Electron 原生支持,集成简单
  - ✅ 代码量少

  缺点:
  - ❌ 主进程不适合复杂业务逻辑
  - ❌ API Key 暴露在 Electron 代码中(相对不安全)
  - ❌ 难以扩展和维护

  ---
  方案三: 内嵌本地 LLM (未来考虑)

  适用于完全离线环境,暂不推荐:
  - 使用 Ollama 或 llama.cpp 运行本地模型
  - 打包体积会非常大(数GB)
  - 性能要求高
  - 开发成本高

  ---
  推荐方案详细设计

  采用方案一: Electron + 轻量 Node 后端

  1. 目录结构

  dreambook/
  ├── src/                    # React 前端
  │   └── services/
  │       └── aiService.ts    # AI 服务调用封装
  ├── backend/                # 新增后端目录
  │   ├── src/
  │   │   ├── index.ts
  │   │   ├── config.ts
  │   │   ├── routes/
  │   │   │   └── chat.ts
  │   │   ├── services/
  │   │   │   └── deepseek.ts
  │   │   └── prompts/
  │   │       └── system.ts
  │   ├── package.json
  │   ├── tsconfig.json
  │   └── .env.example
  └── electron/
      └── main.ts             # 启动后端服务

  2. 技术栈选择

  - 后端框架: Express.js (轻量简单)
  - HTTP 客户端: node-fetch 或 axios
  - 环境变量: dotenv
  - TypeScript: 保持类型安全
  - 打包: 使用 esbuild 打包后端代码

  3. 启动流程

  1. 用户双击 Electron 应用
  2. Electron 主进程启动
  3. 主进程启动 Node 后端服务(localhost:3000)
  4. 主进程创建浏览器窗口,加载前端
  5. 前端通过 fetch('http://localhost:3000/api/dream-chat') 调用

  4. 开发流程

  - 开发环境: 手动启动后端 npm run dev:backend
  - 生产环境: Electron 自动启动后端

  5. 配置管理

  // backend/src/config.ts
  export const config = {
    port: process.env.PORT || 3000,
    deepseek: {
      apiKey: process.env.DEEPSEEK_API_KEY || '',
      apiUrl: process.env.DEEPSEEK_API_URL || 'https://api.deepseek.com',
      model: 'deepseek-chat',
      temperature: 0.7,
      maxTokens: 600,
    },
    cors: {
      origin: ['http://localhost:5173', 'file://*'], // 允许 Electron
    }
  }

  6. System Prompt 管理

  直接使用文档中提供的 Prompt,存储为常量:
  // backend/src/prompts/system.ts
  export const DREAM_SYSTEM_PROMPT = `
  你是一名温和、理性、以心理学和日常生活经验为参考的「梦境解析助手」...
  (文档中的完整内容)
  `

  7. 前端服务封装

  // src/services/aiService.ts
  export class AIService {
    private baseURL = import.meta.env.DEV
      ? 'http://localhost:3000'
      : 'http://localhost:3000' // 生产环境也是本地

    async askDream(question: string): Promise<string> {
      const response = await fetch(`${this.baseURL}/api/dream-chat`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ question })
      })

      if (!response.ok) throw new Error('AI 服务暂时不可用')

      const data = await response.json()
      return data.answer
    }
  }

  8. 部署考虑

  - 打包后端: 使用 esbuild 打包成单文件
  - 资源路径: 使用 app.getAppPath() 定位后端代码
  - 端口冲突: 启动前检测端口是否占用
  - 进程管理: 应用退出时关闭后端服务

  ---
  实施步骤建议

  1. 第一阶段: 独立后端验证
    - 创建 backend 目录
    - 实现 Express 服务 + DeepSeek 调用
    - 手动测试接口
  2. 第二阶段: 前端集成
    - 创建 aiService.ts
    - 添加 AI 对话 UI 组件
    - 手动启动后端,前端调用测试
  3. 第三阶段: Electron 集成
    - 在 electron/main.ts 中集成后端启动逻辑
    - 打包测试
    - 处理异常情况(端口占用、网络异常等)
  4. 第四阶段: 优化打磨
    - 添加加载状态、错误提示
    - 优化 UI 交互
    - 性能测试

  ---
  潜在风险及应对

  1. 网络依赖: 图书馆可能无外网
    - 应对: 提前确认网络环境,或准备降级方案(纯文本展示预设内容)
  2. API 成本: DeepSeek 调用需要付费
    - 应对: 设置速率限制(如每用户每小时10次)
  3. 配置复杂: API Key 需要配置
    - 应对: 提供配置界面或配置文件模板
  4. 打包体积: 后端依赖增加体积
    - 应对: 使用 esbuild 打包,tree-shaking,预计增加 5-10MB

  ---
  总结

  最佳方案: 方案一(Electron + Node 后端)

  核心理由:
  - 符合文档推荐的 MVP 架构
  - 前后端分离,易于开发和维护
  - 可以无缝集成到 Electron
  - 满足"不过度设计"的原则

  关键注意:
  - 先独立开发验证后端
  - 确认图书馆网络环境
  - API Key 安全管理
  - 做好错误提示和降级处理

  这个方案既简单实用,又留有扩展空间(如后续加 RAG 只需改后端逻辑)。