 📊 当前架构分析

  后端 (code/backend/)

  - 技术栈: Express.js + TypeScript
  - 功能: DeepSeek API 代理转发
  - 接口:
    - GET /health - 健康检查
    - POST /api/dream-chat - 梦境解析(转发到DeepSeek)
  - 依赖: 需要 DEEPSEEK_API_KEY 环境变量

  前端 (code/backend/web/)

  - 技术栈: React + Vite + TypeScript
  - 功能: DeepSeek 的 Web UI 界面
  - API调用: 通过 /api 路径调用后端服务
  - 配置: 支持 VITE_API_URL 环境变量指定后端地址

  🎯 推荐部署方案(按优先级排序)

  方案1: 静态前端 + 独立后端 (推荐 ⭐⭐⭐⭐⭐)

  架构:
  用户浏览器 → Nginx/Caddy (静态文件)
                ↓ (API代理)
             Node.js 后端 (PM2/systemd)
                ↓
             DeepSeek API

  优点:
  - 前后端分离,互不影响
  - Nginx 提供高性能静态文件服务
  - 后端可以独立重启/更新
  - 支持 HTTPS、gzip 压缩、缓存等优化
  - 资源占用最小

  部署步骤:
  1. 构建前端:
  cd code/backend/web
  VITE_API_URL=/api yarn build
  # 产物在 dist/ 目录
  2. 构建后端:
  cd code/backend
  yarn build
  # 产物在 dist/ 目录
  3. 服务器配置:
    - 前端: 将 web/dist/ 部署到 Nginx 根目录
    - 后端: 将 backend/ 整个目录上传,用 PM2 运行
    - Nginx 配置 /api 反向代理到后端端口

  Nginx 配置示例:
  server {
      listen 80;
      server_name your-domain.com;

      # 前端静态文件
      location / {
          root /var/www/dreambook-web;
          try_files $uri $uri/ /index.html;
      }

      # 后端 API 代理
      location /api {
          proxy_pass http://127.0.0.1:3000;
          proxy_http_version 1.1;
          proxy_set_header Upgrade $http_upgrade;
          proxy_set_header Connection 'upgrade';
          proxy_set_header Host $host;
          proxy_cache_bypass $http_upgrade;
      }

      location /health {
          proxy_pass http://127.0.0.1:3000;
      }
  }

  PM2 启动后端:
  pm2 start dist/index.js --name dreambook-backend
  pm2 save
  pm2 startup

  ---
  方案2: 后端托管前端 (简单快速 ⭐⭐⭐⭐)

  架构:
  用户浏览器 → Node.js (Express 提供静态文件 + API)
                ↓
             DeepSeek API

  优点:
  - 只需要一个 Node.js 进程
  - 配置简单,适合小流量场景
  - 只需要一个端口

  实现方法:
  修改后端 src/index.ts,添加静态文件服务:
  // 在路由前添加
  app.use(express.static(path.join(__dirname, '../web/dist')))

  // 所有非 API 请求返回 index.html (SPA 路由)
  app.get('*', (req, res) => {
    if (!req.path.startsWith('/api') && !req.path.startsWith('/health')) {
      res.sendFile(path.join(__dirname, '../web/dist/index.html'))
    }
  })

  部署步骤:
  1. 构建前后端(前端 VITE_API_URL 不设置,使用相对路径)
  2. 将前端 dist/ 复制到后端目录
  3. 用 PM2 启动后端即可

  ---
  方案3: Docker 容器化 (标准化 ⭐⭐⭐⭐)

  架构:
  Nginx 容器 (前端) ←→ Node.js 容器 (后端)
                          ↓
                     DeepSeek API

  Dockerfile 示例:
  # 后端
  FROM node:20-alpine
  WORKDIR /app
  COPY backend/package*.json ./
  RUN npm install --production
  COPY backend/dist ./dist
  ENV NODE_ENV=production
  ENV PORT=3000
  EXPOSE 3000
  CMD ["node", "dist/index.js"]

  docker-compose.yml:
  services:
    backend:
      build: ./backend
      environment:
        - DEEPSEEK_API_KEY=${DEEPSEEK_API_KEY}
      ports:
        - "3000:3000"

    frontend:
      image: nginx:alpine
      volumes:
        - ./web/dist:/usr/share/nginx/html
        - ./nginx.conf:/etc/nginx/conf.d/default.conf
      ports:
        - "80:80"
      depends_on:
        - backend

  ---
  方案4: Serverless/云函数 (按量付费 ⭐⭐⭐)

  适用平台: Vercel / Netlify / 阿里云函数计算

  架构:
  - 前端: 部署到 CDN
  - 后端: 部署为云函数

  限制:
  - 云函数有冷启动延迟
  - 需要改造后端为函数式入口
  - 适合低频访问场景

  ---
  💡 最佳实践建议

  根据你的实际情况选择:
  ┌─────────────────┬──────────┬───────────────────────┐
  │      场景       │ 推荐方案 │         原因          │
  ├─────────────────┼──────────┼───────────────────────┤
  │ 个人项目/小流量 │ 方案2    │ 最简单,一个进程搞定   │
  ├─────────────────┼──────────┼───────────────────────┤
  │ 正式生产环境    │ 方案1    │ 性能最好,最灵活       │
  ├─────────────────┼──────────┼───────────────────────┤
  │ 多环境部署      │ 方案3    │ 环境一致性好          │
  ├─────────────────┼──────────┼───────────────────────┤
  │ 预算有限        │ 方案4    │ 按量付费,流量低时便宜 │
  └─────────────────┴──────────┴───────────────────────┘
  🔧 部署清单

  无论哪种方案,都需要:

  1. 环境变量: 配置 DEEPSEEK_API_KEY
  2. 端口开放: 确保防火墙允许访问
  3. HTTPS: 建议用 Let's Encrypt 免费证书
  4. 监控: 配置日志和健康检查
  5. 备份: 如果有数据存储需求

  🎬 我的推荐

  如果是第一次部署:
  先用方案2(后端托管前端),一条命令搞定,熟悉流程后再优化到方案1。

  如果追求性能: 直接上方案1,Nginx + PM2 是业界标准方案。

  需要我帮你实现具体哪个方案的配置代码吗?